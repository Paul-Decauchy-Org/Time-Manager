name: Time Manager CI/CD Pipeline

on:
  push:
  pull_request:
    branches: ["main"]

jobs:
  # ============================================
  # Block 1: Code Quality (lint back, lint front)
  # ============================================
  quality-check:
    runs-on: ubuntu-latest
    name: Code Quality
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Install backend deps
        run: |
          cd back
          go mod download

      - name: Lint backend (go vet)
        working-directory: back
        run: go vet ./...

      - name: Check backend formatting (gofmt)
        working-directory: back
        run: |
          UNFORMATTED=$(gofmt -l .)
          if [ -n "$UNFORMATTED" ]; then
            echo "::error::Go files need formatting:" 
            echo "$UNFORMATTED"
            exit 1
          else
            echo "All Go files are properly formatted."
          fi

      - name: Setup Node.js (frontend)
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: front/package-lock.json

      - name: Install frontend deps
        run: |
          cd front
          npm ci

      # - name: Lint frontend (Biome)
      #   working-directory: front
      #   run: npm run lint -- --max-diagnostics=200

      # - name: Check frontend formatting (Biome)
      #   working-directory: front
      #   run: npm run format:check

  # ============================================
  # Block 3: Generate GraphQL artifacts (gqlgen back, codegen front)
  # ============================================
  generate-graphql:
    runs-on: ubuntu-latest
    name: "Generation GraphQL Artifacts"
    needs: [quality-check]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"
          cache: true
          cache-dependency-path: back/go.sum

      - name: Generate backend GraphQL
        working-directory: back
        run: |
          # run gqlgen via go run to avoid requiring a global binary
          go run github.com/99designs/gqlgen@v0.17.81 generate

      - name: Setup Node.js (for codegen)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install frontend deps (needed for codegen)
        working-directory: front
        run: npm ci

      - name: Generate frontend GraphQL
        working-directory: front
        run: npm run codegen

      - name: Upload generated artifacts (optional)
        uses: actions/upload-artifact@v4
        with:
          name: generated-graphql
          path: |
            back/gqlgen.yml
            front/generated
          retention-days: 1

  # ============================================
  # Block 3.5: Frontend Build (install, codegen, build)
  # ============================================
  frontend-build:
    runs-on: ubuntu-latest
    name: Frontend Build
    needs: [generate-graphql]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: front/package-lock.json

      - name: Install frontend dependencies
        working-directory: front
        run: |
          npm ci

      - name: Generate frontend GraphQL types (safety)
        working-directory: front
        run: npm run codegen

      - name: Build Next.js frontend
        working-directory: front
        run: npm run build

      - name: Upload frontend build artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: front/.next/
          retention-days: 1

      - name: Run frontend tests and generate lcov (optional)
        working-directory: front
        run: |
          # Attempt to run frontend tests to generate lcov (don't fail the job if tests are missing or fail)
          npm run test -- --coverage --coverageReporters=lcov --watchAll=false || true

      - name: Check frontend coverage
        id: check_front_cov
        run: |
          if [ -f front/coverage/lcov.info ]; then
            echo "coverage_exists=true" >> $GITHUB_OUTPUT
          else
            echo "coverage_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload frontend coverage
        if: steps.check_front_cov.outputs.coverage_exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: front-coverage
          path: front/coverage/lcov.info
          retention-days: 7

  # ============================================
  # Block 4: Tests (backend & frontend) - commented for now
  # ============================================
  tests:
    runs-on: ubuntu-latest
    name: Tests (backend & frontend)
    needs: [generate-graphql]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      # Backend tests
      - name: Run backend tests
        working-directory: back
        run: |
          cp .env.example .env || true
          # Fail fast semantics with readable logs: capture output to test.log
          set -o pipefail || true
          go test ./... -v 2>&1 | tee test.log
      - name: Show test failures (tail)
        working-directory: back
        run: |
          # print any FAIL lines and last 200 lines to the log for quick debugging
          grep -n "FAIL" test.log || true
          echo '--- last 200 lines of test.log ---'
          tail -n 200 test.log || true
      - name: Upload backend test log
        uses: actions/upload-artifact@v4
        with:
          name: backend-test-log
          path: back/test.log
          retention-days: 7
      # backend coverage generation/upload removed per request

      # Frontend tests (commented for now)
      # - name: Run frontend tests
      #   working-directory: front
      #   run: |
      #     npm test -- --watchAll=false

  # ============================================
  # Block 5: Docker build
  # ============================================
  docker-build:
    runs-on: ubuntu-latest
    name: Docker Build
    needs: [frontend-build, tests]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Prepare backend env
        run: |
          cd back
          cp .env.example .env || true

      - name: Build docker images
        run: docker compose build --no-cache

      - name: Upload docker metadata (optional)
        uses: actions/upload-artifact@v4
        with:
          name: docker-images-meta
          path: |
            # optionally list files you want to save
          retention-days: 1

  # ============================================
  # Block 6: Docker push (only on main)
  # ============================================
  docker-push:
    runs-on: ubuntu-latest
    needs: [docker-build]
    # Only execute on push events to main (not on PRs)
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compute lowercase owner
        id: gh
        run: |
          echo "owner_lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./back
          file: ./back/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-back:latest
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-back:${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-back:cache
          cache-to: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-back:cache,mode=max

      - name: Push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./front
          file: ./front/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-front:latest
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-front:${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-front:cache
          cache-to: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-front:cache,mode=max

      - name: Push nginx image
        uses: docker/build-push-action@v5
        with:
          context: ./nginx
          file: ./nginx/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-nginx:latest
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-nginx:${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-nginx:cache
          cache-to: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-nginx:cache,mode=max

      - name: Tag database image (official postgres)
        run: |
          docker pull postgres:16-alpine
          docker tag postgres:16-alpine ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-postgres:16-alpine
          docker tag postgres:16-alpine ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-postgres:${{ github.sha }}
          docker push ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-postgres:16-alpine
          docker push ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-postgres:${{ github.sha }}

      - name: Summary
        run: |
          echo "Images pushed to GHCR (latest + SHA):" >> $GITHUB_STEP_SUMMARY
          echo " - back" >> $GITHUB_STEP_SUMMARY
          echo " - front" >> $GITHUB_STEP_SUMMARY
          echo " - nginx" >> $GITHUB_STEP_SUMMARY
          echo " - postgres (re-tag of official)" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # SonarCloud scan (backend + frontend) using SonarCloud GitHub Action
  # requires secret: SONAR_TOKEN (organization key is read from sonar-project.properties)
  # ============================================
  sonarcloud-scan:
    runs-on: ubuntu-latest
    environment: secrets
    name: SonarCloud Scan (backend + frontend)
    needs: [tests, frontend-build]
    env:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    steps:
      - name: Verify SonarCloud secrets
        run: |
          if [ -z "$SONAR_TOKEN" ]; then
            echo "::error::Missing SONAR_TOKEN secret. Please add it in Settings → Secrets → Actions."
            exit 1
          else
            echo "Sonar token present. Proceeding with scan."
          fi

      - name: Verify SonarCloud organization and token (API check)
        run: |
          echo "Checking SonarCloud token validity..."
          token_resp=$(curl -s -u "$SONAR_TOKEN": "https://sonarcloud.io/api/authentication/validate")
          echo "$token_resp" | grep -q '"valid":true' || {
            echo "::error::Invalid SONAR_TOKEN or missing permissions. Generate a token in SonarCloud (Account → Security) within the target organization."
            exit 1
          }

          # Read organization key from sonar-project.properties to avoid mismatch with secrets
          ORG_KEY=$(grep -E '^sonar.organization=' sonar-project.properties | cut -d= -f2 | tr -d '\r')
          if [ -z "$ORG_KEY" ]; then
            echo "::error::Could not read sonar.organization from sonar-project.properties."
            exit 1
          fi
          echo "Checking SonarCloud organization access for key '$ORG_KEY'..."
          org_status=$(curl -s -o /dev/null -w "%{http_code}" -u "$SONAR_TOKEN": "https://sonarcloud.io/api/organizations/show?key=$ORG_KEY")
          if [ "$org_status" != "200" ]; then
            echo "::error::SonarCloud organization '$ORG_KEY' not found or the token cannot access it."
            echo "Ensure sonar.organization in sonar-project.properties is the organization KEY (e.g. 'paul-decauchy-org'), not the display name, and the token belongs to that org."
            exit 1
          fi
          echo "Token valid and organization accessible."

      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Download backend coverage (if uploaded)
        uses: actions/download-artifact@v4
        with:
          name: backend-coverage
          path: back
        continue-on-error: true

      - name: Download frontend coverage (if uploaded)
        uses: actions/download-artifact@v4
        with:
          name: front-coverage
          path: front/coverage
        continue-on-error: true

      - name: SonarCloud Scan (monorepo)
        uses: SonarSource/sonarcloud-github-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Notify SonarCloud scan finished
        run: echo "SonarCloud scans finished for backend and frontend. Check SonarCloud dashboard."
