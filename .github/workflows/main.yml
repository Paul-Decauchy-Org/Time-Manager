name: Time Manager CI/CD Pipeline

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]

jobs:
  # ============================================
  # Block 1: Code Quality (lint back, lint front)
  # ============================================
  quality-check:
    runs-on: ubuntu-latest
    name: Code Quality
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Install backend deps
        run: |
          cd back
          go mod download

      - name: Lint backend (go vet)
        working-directory: back
        run: go vet ./...

      - name: Check backend formatting (gofmt)
        working-directory: back
        run: |
          UNFORMATTED=$(gofmt -l .)
          if [ -n "$UNFORMATTED" ]; then
            echo "::error::Go files need formatting:" 
            echo "$UNFORMATTED"
            exit 1
          else
            echo "All Go files are properly formatted."
          fi

      - name: Setup Node.js (frontend)
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: front/package-lock.json

      - name: Install frontend deps
        run: |
          cd front
          npm ci
      # - name: Lint frontend (Biome)
      #   working-directory: front
      #   run: npm run lint -- --max-diagnostics=200

      # - name: Check frontend formatting (Biome)
      #   working-directory: front
      #   run: npm run format:check

  # ============================================
  # Block 3: Generate GraphQL artifacts (gqlgen back, codegen front)
  # ============================================
  generate-graphql:
    runs-on: ubuntu-latest
    name: "Generation GraphQL Artifacts"
    needs: [quality-check]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"
          cache: true
          cache-dependency-path: back/go.sum

      - name: Generate backend GraphQL
        working-directory: back
        run: |
          # run gqlgen via go run to avoid requiring a global binary
          go run github.com/99designs/gqlgen@v0.17.81 generate

      - name: Setup Node.js (for codegen)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install frontend deps (needed for codegen)
        working-directory: front
        run: npm ci

      - name: Generate frontend GraphQL
        working-directory: front
        run: npm run codegen

      - name: Upload generated artifacts (optional)
        uses: actions/upload-artifact@v4
        with:
          name: generated-graphql
          path: |
            back/gqlgen.yml
            front/generated
          retention-days: 1

  # ============================================
  # Block 3.5: Frontend Build (install, codegen, build)
  # ============================================
  frontend-build:
    runs-on: ubuntu-latest
    name: Frontend Build
    needs: [generate-graphql]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: front/package-lock.json

      - name: Install frontend dependencies
        working-directory: front
        run: |
          npm ci

      - name: Generate frontend GraphQL types (safety)
        working-directory: front
        run: npm run codegen

      - name: Build Next.js frontend
        working-directory: front
        run: npm run build

      - name: Upload frontend build artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: front/.next/
          retention-days: 1

      - name: Run frontend tests and generate lcov (optional)
        working-directory: front
        run: |
          # Attempt to run frontend tests to generate lcov (don't fail the job if tests are missing or fail)
          npm run test -- --coverage --coverageReporters=lcov --watchAll=false || true

      - name: Check frontend coverage
        id: check_front_cov
        run: |
          if [ -f front/coverage/lcov.info ]; then
            echo "coverage_exists=true" >> $GITHUB_OUTPUT
          else
            echo "coverage_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload frontend coverage
        if: steps.check_front_cov.outputs.coverage_exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: front-coverage
          path: front/coverage/lcov.info
          retention-days: 7

  # ============================================
  # Block 4: Tests (backend & frontend) - commented for now
  # ============================================
  tests:
    runs-on: ubuntu-latest
    name: Tests (backend & frontend)
    needs: [generate-graphql]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      # Backend tests
      - name: Run backend tests with coverage and JSON report (best-effort)
        working-directory: back
        continue-on-error: true
        run: |
          cp .env.example .env || true
          set -o pipefail || true
          # Single invocation to produce both coverage and JSON report
          go test ./... -coverprofile=coverage.out -covermode=atomic -v -json | tee test-report.json

      - name: Check backend coverage
        id: check_back_cov
        working-directory: back
        run: |
          if [ -f coverage.out ]; then
            echo "coverage_exists=true" >> $GITHUB_OUTPUT
          else
            echo "coverage_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload backend coverage
        if: steps.check_back_cov.outputs.coverage_exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: backend-coverage
          path: back/coverage.out
          retention-days: 7

      - name: Check backend test report
        id: check_back_report
        working-directory: back
        run: |
          if [ -f test-report.json ]; then
            echo "report_exists=true" >> $GITHUB_OUTPUT
          else
            echo "report_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload backend test report (JSON)
        if: steps.check_back_report.outputs.report_exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: backend-test-report
          path: back/test-report.json
          retention-days: 7
      # backend coverage generation/upload removed per request

      # Frontend tests (commented for now)
      # - name: Run frontend tests
      #   working-directory: front
      #   run: |
      #     npm test -- --watchAll=false

  # ============================================
  # Block 5: Docker build
  # ============================================
  docker-build:
    runs-on: ubuntu-latest
    name: Docker Build
    needs: [frontend-build, tests]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Prepare backend env
        run: |
          cd back
          cp .env.example .env || true

      - name: Build docker images
        run: docker compose build --no-cache

      - name: Upload docker metadata (optional)
        uses: actions/upload-artifact@v4
        with:
          name: docker-images-meta
          path: |
            # optionally list files you want to save
          retention-days: 1

  # ============================================
  # Block 6: Docker push (only on main)
  # ============================================
  docker-push:
    runs-on: ubuntu-latest
    needs: [docker-build]
    # Only execute on push events to main (not on PRs)
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compute lowercase owner
        id: gh
        run: |
          echo "owner_lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./back
          file: ./back/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-back:latest
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-back:${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-back:cache
          cache-to: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-back:cache,mode=max

      - name: Push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./front
          file: ./front/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-front:latest
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-front:${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-front:cache
          cache-to: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-front:cache,mode=max

      - name: Push nginx image
        uses: docker/build-push-action@v5
        with:
          context: ./nginx
          file: ./nginx/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-nginx:latest
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-nginx:${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-nginx:cache
          cache-to: type=registry,ref=ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-nginx:cache,mode=max

      - name: Tag database image (official postgres)
        run: |
          docker pull postgres:16-alpine
          docker tag postgres:16-alpine ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-postgres:16-alpine
          docker tag postgres:16-alpine ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-postgres:${{ github.sha }}
          docker push ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-postgres:16-alpine
          docker push ghcr.io/${{ steps.gh.outputs.owner_lc }}/time-manager-postgres:${{ github.sha }}

      - name: Summary
        run: |
          echo "Images pushed to GHCR (latest + SHA):" >> $GITHUB_STEP_SUMMARY
          echo " - back" >> $GITHUB_STEP_SUMMARY
          echo " - front" >> $GITHUB_STEP_SUMMARY
          echo " - nginx" >> $GITHUB_STEP_SUMMARY
          echo " - postgres (re-tag of official)" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # SonarCloud scan (backend + frontend) using SonarCloud GitHub Action
  # requires secret: SONAR_TOKEN (organization key is read from sonar-project.properties)
  # ============================================
  sonarcloud-scan:
    runs-on: ubuntu-latest
    environment: secrets
    name: SonarCloud Scan (backend + frontend)
    needs: [tests, frontend-build]
    env:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0 
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v6
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

