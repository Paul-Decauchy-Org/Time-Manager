name: Time Manager CI/CD Pipeline

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]

jobs:
  # ============================================
  # Block 1: Code Quality (lint back, lint front)
  # ============================================
  quality-check:
    runs-on: ubuntu-latest
    name: Code Quality
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Install backend deps
        run: |
          cd back
          go mod download

      - name: Lint backend (go vet)
        working-directory: back
        run: go vet ./...

      - name: Check backend formatting (gofmt)
        working-directory: back
        run: |
          UNFORMATTED=$(gofmt -l .)
          if [ -n "$UNFORMATTED" ]; then
            echo "::error::Go files need formatting:" 
            echo "$UNFORMATTED"
            exit 1
          else
            echo "All Go files are properly formatted."
          fi

      - name: Setup Node.js (frontend)
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: front/package-lock.json

      - name: Install frontend deps
        run: |
          cd front
          npm ci
      # - name: Lint frontend (Biome)
      #   working-directory: front
      #   run: npm run lint -- --max-diagnostics=200

      # - name: Check frontend formatting (Biome)
      #   working-directory: front
      #   run: npm run format:check

  # ============================================
  # Block 3: Generate GraphQL artifacts (gqlgen back, codegen front)
  # ============================================
  generate-graphql:
    runs-on: ubuntu-latest
    name: "Generation GraphQL Artifacts"
    needs: [quality-check]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"
          cache: true
          cache-dependency-path: back/go.sum

      - name: Generate backend GraphQL
        working-directory: back
        run: |
          # run gqlgen via go run to avoid requiring a global binary
          go run github.com/99designs/gqlgen@v0.17.81 generate

      - name: Setup Node.js (for codegen)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install frontend deps (needed for codegen)
        working-directory: front
        run: npm ci

      - name: Generate frontend GraphQL
        working-directory: front
        run: npm run codegen

      - name: Upload generated artifacts (optional)
        uses: actions/upload-artifact@v4
        with:
          name: generated-graphql
          path: |
            back/gqlgen.yml
            front/generated
          retention-days: 1

  # ============================================
  # Block 3.5: Frontend Build (install, codegen, build)
  # ============================================
  frontend-build:
    runs-on: ubuntu-latest
    name: Frontend Build
    needs: [generate-graphql]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: front/package-lock.json

      - name: Install frontend dependencies
        working-directory: front
        run: |
          npm ci

      - name: Generate frontend GraphQL types (safety)
        working-directory: front
        run: npm run codegen

      - name: Build Next.js frontend
        working-directory: front
        run: npm run build

      - name: Upload frontend build artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: front/.next/
          retention-days: 1

      - name: Run frontend tests and generate lcov (optional)
        working-directory: front
        run: |
          # Attempt to run frontend tests to generate lcov (don't fail the job if tests are missing or fail)
          npm run test -- --coverage --coverageReporters=lcov --watchAll=false || true

      - name: Check frontend coverage
        id: check_front_cov
        run: |
          if [ -f front/coverage/lcov.info ]; then
            echo "coverage_exists=true" >> $GITHUB_OUTPUT
          else
            echo "coverage_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload frontend coverage
        if: steps.check_front_cov.outputs.coverage_exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: front-coverage
          path: front/coverage/lcov.info
          retention-days: 7

  # ============================================
  # Block 4: Tests (backend & frontend) - commented for now
  # ============================================
  tests:
    runs-on: ubuntu-latest
    name: Tests (backend & frontend)
    needs: [generate-graphql]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      # Backend tests
      - name: Run backend tests with coverage and JSON report (best-effort)
        working-directory: back
        continue-on-error: true
        run: |
          cp .env.example .env || true
          set -o pipefail || true
          # Single invocation to produce both coverage and JSON report
          go test ./... -coverprofile=coverage.out -covermode=atomic -v -json | tee test-report.json

      - name: Check backend coverage
        id: check_back_cov
        working-directory: back
        run: |
          if [ -f coverage.out ]; then
            echo "coverage_exists=true" >> $GITHUB_OUTPUT
          else
            echo "coverage_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload backend coverage
        if: steps.check_back_cov.outputs.coverage_exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: backend-coverage
          path: back/coverage.out
          retention-days: 7

      - name: Check backend test report
        id: check_back_report
        working-directory: back
        run: |
          if [ -f test-report.json ]; then
            echo "report_exists=true" >> $GITHUB_OUTPUT
          else
            echo "report_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload backend test report (JSON)
        if: steps.check_back_report.outputs.report_exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: backend-test-report
          path: back/test-report.json
          retention-days: 7
      # backend coverage generation/upload removed per request

      # Frontend tests (commented for now)
      # - name: Run frontend tests
      #   working-directory: front
      #   run: |
      #     npm test -- --watchAll=false

  # ============================================
  # Block 5: Docker build
  # ============================================
  docker-build:
    runs-on: ubuntu-latest
    name: Docker Build
    needs: [frontend-build, tests]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Prepare backend env
        run: |
          cd back
          cp .env.example .env || true

      - name: Build docker images
        run: docker compose build --no-cache

      - name: Upload docker metadata (optional)
        uses: actions/upload-artifact@v4
        with:
          name: docker-images-meta
          path: |
            # optionally list files you want to save
          retention-days: 1

  # ============================================
  # Block 6: Docker push (only on main)
  # ============================================
  docker-push:
    runs-on: ubuntu-latest
    needs: [docker-build]
    # Only execute on push events to main (not on PRs)
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        include:
          - component: back
            context: ./back
            dockerfile: ./back/Dockerfile
            image: time-manager-back
          - component: front
            context: ./front
            dockerfile: ./front/Dockerfile
            image: time-manager-front
          - component: nginx
            context: ./nginx
            dockerfile: ./nginx/Dockerfile
            image: time-manager-nginx
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compute lowercase owner
        id: gh
        run: echo "owner_lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: true
          tags: |
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/${{ matrix.image }}:latest
            ghcr.io/${{ steps.gh.outputs.owner_lc }}/${{ matrix.image }}:${{ github.sha }}
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ============================================
  # SonarCloud scan (backend + frontend) using SonarCloud GitHub Action
  # requires secret: SONAR_TOKEN (organization key is read from sonar-project.properties)
  # ============================================
  sonarcloud-scan:
    runs-on: ubuntu-latest
    environment: secrets
    name: SonarCloud Scan
    needs: [tests]
    env:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Download backend coverage artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-coverage
          path: .
      - name: Normalize coverage file location and paths
        run: |
          echo "Checking downloaded coverage artifact..."
          if [ -f coverage.out ]; then
            echo "Found coverage.out at repo root; relocating to back/coverage.out"
            mkdir -p back
            mv coverage.out back/coverage.out
          elif [ -f back/coverage.out ]; then
            echo "Found back/coverage.out directly."
          else
            echo "::error::No coverage.out file found after artifact download";
            exit 1
          fi
          echo "Sample BEFORE prefix (first 5 non-mode lines):"
          grep -v '^mode:' back/coverage.out | head -n 5 || true
          # Prefix paths with 'back/' if they don't already start with it (skip mode line)
          if grep -v '^mode:' back/coverage.out | grep -q '^[^b]'; then
            echo "Applying path prefix 'back/' to coverage entries";
            sed -i '/^mode:/! s|^|back/|' back/coverage.out
          else
            echo "Paths already appear prefixed; skipping sed.";
          fi
          echo "Sample AFTER prefix (first 5 non-mode lines):"
          grep -v '^mode:' back/coverage.out | head -n 5 || true
      - name: Verify downloaded coverage file
        run: |
          echo "Repo root listing (truncated):"
          ls -l | head -n 30
          echo "\nCoverage file sample (20 lines) from back/coverage.out:"
          head -n 20 back/coverage.out
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@v2
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          args: >
            -Dsonar.go.coverage.reportPaths=back/coverage.out
